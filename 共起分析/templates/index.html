<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•†å“å…±èµ·åˆ†æãƒ„ãƒ¼ãƒ«</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7fa;
            color: #333;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 350px;
            background: white;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            overflow-y: auto;
            padding: 20px;
        }

        .main-content {
            flex: 1;
            padding: 20px;
            overflow: hidden;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        h2 {
            font-size: 18px;
            margin: 20px 0 10px 0;
            color: #34495e;
        }

        .control-group {
            margin-bottom: 25px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        select, input[type="date"], input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            background: white;
        }

        select[multiple] {
            min-height: 150px;
        }

        .slider-container {
            margin-top: 10px;
        }

        .slider-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        #network {
            width: 100%;
            height: calc(100vh - 40px);
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .radio-group {
            display: flex;
            gap: 20px;
            margin: 10px 0;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: normal;
            cursor: pointer;
        }

        .period-inputs {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
        }

        .period-inputs.active {
            display: block;
        }

        .date-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 5px;
        }

        .date-input-group input {
            flex: 1;
        }

        .node {
            cursor: pointer;
            stroke: #fff;
            stroke-width: 2px;
        }

        .link {
            stroke-opacity: 0.6;
        }

        .node-label {
            font-size: 11px;
            pointer-events: none;
            text-anchor: middle;
            font-weight: 600;
        }

        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            padding: 20px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
        }

        .popup.active {
            display: block;
        }

        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }

        .popup-overlay.active {
            display: block;
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .popup-header h3 {
            font-size: 18px;
            color: #2c3e50;
        }

        .close-btn {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            background: #c0392b;
        }

        /* è¡¨å½¢å¼ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .cooccurrence-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .cooccurrence-table thead {
            background: #f8f9fa;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .cooccurrence-table th {
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            cursor: pointer;
            user-select: none;
        }

        .cooccurrence-table th:hover {
            background: #e9ecef;
        }

        .cooccurrence-table th.sortable::after {
            content: ' â†•';
            color: #999;
            font-size: 12px;
        }

        .cooccurrence-table th.sort-asc::after {
            content: ' â†‘';
            color: #3498db;
        }

        .cooccurrence-table th.sort-desc::after {
            content: ' â†“';
            color: #3498db;
        }

        .cooccurrence-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #e0e0e0;
        }

        .cooccurrence-table tbody tr:hover {
            background: #f8f9fa;
        }

        .cooccurrence-table tbody tr:nth-child(even) {
            background: #fafbfc;
        }

        .cooccurrence-table tbody tr:nth-child(even):hover {
            background: #f0f2f5;
        }

        .cooccurrence-table .item-name {
            font-weight: 600;
            color: #2c3e50;
        }

        .cooccurrence-table .numeric {
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        .info-text {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 12px;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ã‚µã‚¤ãƒ‰ãƒãƒ¼: ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« -->
        <div class="sidebar">
            <h1>ğŸ“Š å…±èµ·åˆ†æãƒ„ãƒ¼ãƒ«</h1>

            <!-- éšå±¤é¸æŠ -->
            <div class="control-group">
                <h2>éšå±¤é¸æŠ</h2>
                <label>åˆ†æã™ã‚‹éšå±¤</label>
                <select id="hierarchy-select">
                    <option value="">é¸æŠã—ã¦ãã ã•ã„</option>
                    <option value="ãƒ‡ã‚£ãƒ“ã‚¸ãƒ§ãƒ³">ãƒ‡ã‚£ãƒ“ã‚¸ãƒ§ãƒ³</option>
                    <option value="ãƒ©ã‚¤ãƒ³">ãƒ©ã‚¤ãƒ³</option>
                    <option value="éƒ¨é–€">éƒ¨é–€</option>
                    <option value="ã‚«ãƒ†ã‚´ãƒªãƒ¼">ã‚«ãƒ†ã‚´ãƒªãƒ¼</option>
                </select>
            </div>

            <!-- é …ç›®é¸æŠ -->
            <div class="control-group">
                <h2>é …ç›®é¸æŠ</h2>
                <label>åˆ†æå¯¾è±¡ã®é …ç›®ï¼ˆè¤‡æ•°é¸æŠå¯ï¼‰</label>
                <select id="items-select" multiple disabled>
                    <option disabled>éšå±¤ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
                </select>
                <p class="info-text">Ctrl/Cmd + ã‚¯ãƒªãƒƒã‚¯ã§è¤‡æ•°é¸æŠ</p>
            </div>

            <!-- å…±èµ·å®šç¾©é¸æŠ -->
            <div class="control-group">
                <h2>å…±èµ·å®šç¾©</h2>
                <div class="radio-group">
                    <label>
                        <input type="radio" name="mode" value="daily" checked>
                        åŒæ™‚ä½µå£²ï¼ˆåŒä¸€æ—¥ï¼‰
                    </label>
                    <label>
                        <input type="radio" name="mode" value="period">
                        æœŸé–“ä½µå£²
                    </label>
                </div>
                
                <div id="period-inputs" class="period-inputs">
                    <label>åˆ†ææœŸé–“</label>
                    <div class="date-input-group">
                        <input type="date" id="start-date">
                        <span>ã€œ</span>
                        <input type="date" id="end-date">
                    </div>
                </div>
            </div>

            <!-- ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼èª¿æ•´ -->
            <div class="control-group">
                <h2>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼èª¿æ•´</h2>
                
                <label>æœ€ä½å…±èµ·å›æ•°</label>
                <div class="slider-container">
                    <div class="slider-input">
                        <input type="range" id="min-cooccurrence-slider" min="1" max="1000" value="2" step="1">
                        <input type="number" id="min-cooccurrence-input" min="1" max="1000" value="2">
                    </div>
                </div>

                <label style="margin-top: 15px;">æœ€ä½ãƒªãƒ•ãƒˆå€¤</label>
                <div class="slider-container">
                    <div class="slider-input">
                        <input type="range" id="min-lift-slider" min="0" max="5" value="1" step="0.1">
                        <input type="number" id="min-lift-input" min="0" max="100" value="1" step="0.1">
                    </div>
                </div>
            </div>

            <!-- å®Ÿè¡Œãƒœã‚¿ãƒ³ -->
            <div class="button-group">
                <button class="btn-primary" id="analyze-btn" disabled>åˆ†æå®Ÿè¡Œ</button>
                <button class="btn-secondary" id="export-btn" disabled>CSVå‡ºåŠ›</button>
            </div>
        </div>

        <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å›³ -->
        <div class="main-content">
            <div id="network"></div>
        </div>
    </div>

    <!-- ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— -->
    <div class="popup-overlay" id="popup-overlay"></div>
    <div class="popup" id="popup">
        <div class="popup-header">
            <h3 id="popup-title">å…±èµ·å•†å“ãƒªã‚¹ãƒˆ</h3>
            <button class="close-btn" id="close-popup">Ã—</button>
        </div>
        <table class="cooccurrence-table" id="cooccurrence-table">
            <thead>
                <tr>
                    <th class="sortable" data-sort="item">å•†å“å</th>
                    <th class="sortable numeric" data-sort="count">å…±èµ·å›æ•°</th>
                    <th class="sortable numeric sort-desc" data-sort="lift">ãƒªãƒ•ãƒˆå€¤</th>
                    <th class="sortable numeric" data-sort="confidence">ä¿¡é ¼åº¦</th>
                </tr>
            </thead>
            <tbody id="cooccurrence-tbody">
            </tbody>
        </table>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let hierarchies = {};
        let networkData = null;
        let currentHierarchy = null;
        let simulation = null;

        // ãƒ‘ã‚¹ãƒ†ãƒ«ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
        const pastelColors = [
            '#FFB6C1', '#FFD700', '#98FB98', '#87CEEB', '#DDA0DD',
            '#F0E68C', '#FFE4B5', '#AFEEEE', '#F5DEB3', '#FFC0CB',
            '#E0BBE4', '#FFDFD3', '#C7CEEA', '#B4F8C8', '#FBE7C6'
        ];

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', async () => {
            await loadHierarchies();
            await loadDateRange();
            setupEventListeners();
            
            // ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ˜ãƒƒãƒ€ãƒ¼ã®ã‚½ãƒ¼ãƒˆæ©Ÿèƒ½ã‚’è¨­å®š
            document.querySelectorAll('.cooccurrence-table th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const column = th.getAttribute('data-sort');
                    
                    // åŒã˜åˆ—ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯æ˜‡é †ãƒ»é™é †ã‚’åˆ‡ã‚Šæ›¿ãˆ
                    if (currentSortColumn === column) {
                        currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
                    } else {
                        // åˆ¥ã®åˆ—ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯é™é †ã‹ã‚‰é–‹å§‹
                        currentSortColumn = column;
                        currentSortOrder = 'desc';
                    }

                    sortCooccurrences(currentSortColumn, currentSortOrder);
                    updateCooccurrenceTable();
                    updateSortHeaders();
                });
            });
        });

        // éšå±¤ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        async function loadHierarchies() {
            const response = await fetch('/api/hierarchies');
            hierarchies = await response.json();
        }

        // æ—¥ä»˜ç¯„å›²ã‚’èª­ã¿è¾¼ã¿
        async function loadDateRange() {
            const response = await fetch('/api/date_range');
            const dateRange = await response.json();
            document.getElementById('start-date').value = dateRange.min_date;
            document.getElementById('end-date').value = dateRange.max_date;
            document.getElementById('start-date').min = dateRange.min_date;
            document.getElementById('start-date').max = dateRange.max_date;
            document.getElementById('end-date').min = dateRange.min_date;
            document.getElementById('end-date').max = dateRange.max_date;
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        function setupEventListeners() {
            // éšå±¤é¸æŠ
            document.getElementById('hierarchy-select').addEventListener('change', (e) => {
                currentHierarchy = e.target.value;
                updateItemsList();
            });

            // ãƒ¢ãƒ¼ãƒ‰é¸æŠ
            document.querySelectorAll('input[name="mode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const periodInputs = document.getElementById('period-inputs');
                    if (e.target.value === 'period') {
                        periodInputs.classList.add('active');
                    } else {
                        periodInputs.classList.remove('active');
                    }
                });
            });

            // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›æ¬„ã®åŒæœŸ
            syncSliderAndInput('min-cooccurrence-slider', 'min-cooccurrence-input');
            syncSliderAndInput('min-lift-slider', 'min-lift-input');

            // é …ç›®é¸æŠ
            document.getElementById('items-select').addEventListener('change', () => {
                const selected = getSelectedItems();
                const analyzeBtn = document.getElementById('analyze-btn');
                analyzeBtn.disabled = selected.length < 2;
            });

            // åˆ†æå®Ÿè¡Œãƒœã‚¿ãƒ³
            document.getElementById('analyze-btn').addEventListener('click', analyzeData);

            // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³
            document.getElementById('export-btn').addEventListener('click', exportData);

            // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚¯ãƒ­ãƒ¼ã‚º
            document.getElementById('close-popup').addEventListener('click', closePopup);
            document.getElementById('popup-overlay').addEventListener('click', closePopup);
        }

        // é …ç›®ãƒªã‚¹ãƒˆã‚’æ›´æ–°
        function updateItemsList() {
            const itemsSelect = document.getElementById('items-select');
            itemsSelect.innerHTML = '';
            itemsSelect.disabled = false;

            if (currentHierarchy && hierarchies[currentHierarchy]) {
                hierarchies[currentHierarchy].forEach(item => {
                    const option = document.createElement('option');
                    option.value = item;
                    option.textContent = item;
                    itemsSelect.appendChild(option);
                });
            }
        }

        // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨å…¥åŠ›æ¬„ã‚’åŒæœŸ
        function syncSliderAndInput(sliderId, inputId) {
            const slider = document.getElementById(sliderId);
            const input = document.getElementById(inputId);

            slider.addEventListener('input', () => {
                input.value = slider.value;
            });

            input.addEventListener('input', () => {
                slider.value = input.value;
            });
        }

        // é¸æŠã•ã‚ŒãŸé …ç›®ã‚’å–å¾—
        function getSelectedItems() {
            const select = document.getElementById('items-select');
            return Array.from(select.selectedOptions).map(opt => opt.value);
        }

        // åˆ†æã‚’å®Ÿè¡Œ
        async function analyzeData() {
            const hierarchy = currentHierarchy;
            const items = getSelectedItems();
            const mode = document.querySelector('input[name="mode"]:checked').value;
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const minCooccurrence = parseInt(document.getElementById('min-cooccurrence-input').value);
            const minLift = parseFloat(document.getElementById('min-lift-input').value);

            if (items.length < 2) {
                alert('2ã¤ä»¥ä¸Šã®é …ç›®ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            const requestData = {
                hierarchy,
                items,
                mode,
                start_date: mode === 'period' ? startDate : null,
                end_date: mode === 'period' ? endDate : null,
                min_cooccurrence: minCooccurrence,
                min_lift: minLift
            };

            try {
                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });

                networkData = await response.json();
                drawNetwork(networkData);
                document.getElementById('export-btn').disabled = false;
            } catch (error) {
                console.error('åˆ†æã‚¨ãƒ©ãƒ¼:', error);
                alert('åˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
            }
        }

        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å›³ã‚’æç”»
        function drawNetwork(data) {
            const container = document.getElementById('network');
            container.innerHTML = '';

            if (!data.nodes || data.nodes.length === 0) {
                container.innerHTML = '<div class="loading">è¡¨ç¤ºã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’èª¿æ•´ã—ã¦ãã ã•ã„ã€‚</div>';
                return;
            }

            const width = container.clientWidth;
            const height = container.clientHeight;

            const svg = d3.select('#network')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // ã‚°ãƒ«ãƒ¼ãƒ—ã”ã¨ã®è‰²ãƒãƒƒãƒ”ãƒ³ã‚°
            const groups = [...new Set(data.nodes.map(d => d.group))];
            const colorScale = d3.scaleOrdinal()
                .domain(groups)
                .range(pastelColors);

            // ãƒãƒ¼ãƒ‰ã®ã‚µã‚¤ã‚ºã‚¹ã‚±ãƒ¼ãƒ«
            const maxSales = d3.max(data.nodes, d => d.size);
            const sizeScale = d3.scaleLinear()
                .domain([0, maxSales])
                .range([10, 40]);

            // ã‚¨ãƒƒã‚¸ã®å¤ªã•ã‚¹ã‚±ãƒ¼ãƒ«
            const maxCount = d3.max(data.edges, d => d.count);
            const widthScale = d3.scaleLinear()
                .domain([0, maxCount])
                .range([1, 10]);

            // ãƒªãƒ•ãƒˆå€¤ã«åŸºã¥ãã‚¨ãƒƒã‚¸ã®è‰²
            const liftColorScale = d3.scaleLinear()
                .domain([0, 1, 2, 3, 5])
                .range(['#e0e0e0', '#cccccc', '#b0b0b0', '#4a90e2', '#2e5c8a'])
                .clamp(true);

            function getLiftColor(lift) {
                if (lift <= 1) {
                    return '#e0e0e0'; // è–„ã„ã‚°ãƒ¬ãƒ¼
                } else if (lift <= 2) {
                    return '#b0b0b0'; // ã‚°ãƒ¬ãƒ¼
                } else {
                    // 2ã‚ˆã‚Šå¤§ãã„å ´åˆã¯é’ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                    return liftColorScale(lift);
                }
            }

            // Force simulation
            simulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.edges)
                    .id(d => d.id)
                    .distance(150))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => sizeScale(d.size) + 5));

            // ã‚¨ãƒƒã‚¸
            const link = svg.append('g')
                .selectAll('line')
                .data(data.edges)
                .enter()
                .append('line')
                .attr('class', 'link')
                .attr('stroke', d => getLiftColor(d.lift))
                .attr('stroke-width', d => widthScale(d.count));

            // ãƒãƒ¼ãƒ‰
            const node = svg.append('g')
                .selectAll('circle')
                .data(data.nodes)
                .enter()
                .append('circle')
                .attr('class', 'node')
                .attr('r', d => sizeScale(d.size))
                .attr('fill', d => colorScale(d.group))
                .on('dblclick', showCooccurrencePopup)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // ãƒ©ãƒ™ãƒ«
            const label = svg.append('g')
                .selectAll('text')
                .data(data.nodes)
                .enter()
                .append('text')
                .attr('class', 'node-label')
                .text(d => d.label)
                .attr('dy', d => sizeScale(d.size) + 15);

            // å‡¡ä¾‹
            const legend = d3.select('#network')
                .append('div')
                .attr('class', 'legend');

            legend.append('div')
                .attr('class', 'legend-title')
                .text(`ã‚°ãƒ«ãƒ¼ãƒ—åˆ¥è‰²åˆ†ã‘: ${data.parent_hierarchy}`);

            groups.forEach(group => {
                const item = legend.append('div')
                    .attr('class', 'legend-item');
                
                item.append('div')
                    .attr('class', 'legend-color')
                    .style('background-color', colorScale(group));
                
                item.append('span')
                    .text(group);
            });

            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // å…±èµ·å•†å“ãƒªã‚¹ãƒˆã‚’ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤º
        let currentCooccurrences = [];
        let currentSortColumn = 'lift';
        let currentSortOrder = 'desc';

        function showCooccurrencePopup(event, d) {
            event.stopPropagation();

            const relatedEdges = networkData.edges.filter(e => 
                e.source.id === d.id || e.target.id === d.id
            );

            currentCooccurrences = relatedEdges.map(e => {
                const isSource = e.source.id === d.id;
                return {
                    item: isSource ? e.target.label : e.source.label,
                    count: e.count,
                    lift: e.lift,
                    confidence: isSource ? e.confidence_a_to_b : e.confidence_b_to_a
                };
            });

            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒªãƒ•ãƒˆå€¤é™é †ã«ã‚½ãƒ¼ãƒˆ
            currentSortColumn = 'lift';
            currentSortOrder = 'desc';
            sortCooccurrences(currentSortColumn, currentSortOrder);

            // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’æ›´æ–°
            document.getElementById('popup-title').textContent = `ã€Œ${d.label}ã€ã®å…±èµ·å•†å“`;
            
            // è¡¨ã‚’æ›´æ–°
            updateCooccurrenceTable();

            // ã‚½ãƒ¼ãƒˆãƒ˜ãƒƒãƒ€ãƒ¼ã®çŠ¶æ…‹ã‚’æ›´æ–°
            updateSortHeaders();

            // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’è¡¨ç¤º
            document.getElementById('popup-overlay').classList.add('active');
            document.getElementById('popup').classList.add('active');
        }

        function updateCooccurrenceTable() {
            const tbody = document.getElementById('cooccurrence-tbody');
            tbody.innerHTML = '';

            currentCooccurrences.forEach(item => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="item-name">${item.item}</td>
                    <td class="numeric">${item.count}å›</td>
                    <td class="numeric">${item.lift.toFixed(3)}</td>
                    <td class="numeric">${(item.confidence * 100).toFixed(1)}%</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function sortCooccurrences(column, order) {
            currentCooccurrences.sort((a, b) => {
                let aVal, bVal;
                
                if (column === 'item') {
                    aVal = a.item;
                    bVal = b.item;
                    return order === 'asc' 
                        ? aVal.localeCompare(bVal, 'ja')
                        : bVal.localeCompare(aVal, 'ja');
                } else {
                    aVal = a[column];
                    bVal = b[column];
                    return order === 'asc' ? aVal - bVal : bVal - aVal;
                }
            });
        }

        function updateSortHeaders() {
            // ã™ã¹ã¦ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‹ã‚‰ã‚½ãƒ¼ãƒˆã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
            document.querySelectorAll('.cooccurrence-table th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // ç¾åœ¨ã®ã‚½ãƒ¼ãƒˆåˆ—ã«ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
            const sortHeader = document.querySelector(`th[data-sort="${currentSortColumn}"]`);
            if (sortHeader) {
                sortHeader.classList.add(currentSortOrder === 'asc' ? 'sort-asc' : 'sort-desc');
            }
        }

        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã‚‹
        function closePopup() {
            document.getElementById('popup-overlay').classList.remove('active');
            document.getElementById('popup').classList.remove('active');
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        async function exportData() {
            const hierarchy = currentHierarchy;
            const items = getSelectedItems();
            const mode = document.querySelector('input[name="mode"]:checked').value;
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const minCooccurrence = parseInt(document.getElementById('min-cooccurrence-input').value);
            const minLift = parseFloat(document.getElementById('min-lift-input').value);

            const requestData = {
                hierarchy,
                items,
                mode,
                start_date: mode === 'period' ? startDate : null,
                end_date: mode === 'period' ? endDate : null,
                min_cooccurrence: minCooccurrence,
                min_lift: minLift
            };

            try {
                const response = await fetch('/api/export', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cooccurrence_export_${new Date().getTime()}.csv`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                console.error('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
            }
        }
    </script>
</body>
</html>
